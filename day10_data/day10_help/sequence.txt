Today's topics
Revise one to many bi dir association between entities
LazyInitializationException --cause & solution
one to one mapping between entities
Entity vs Value Types (weak entities or embeddables)
Handling Blobs

Enter Spring


Advanced Hibernate


1. @MappedSuperclass
class level
Doesn't associate with any table
Super class of entities
Common annotations can be added here.



Associtation between entities
one-to-one  ---@OneToOne
one-to-many ---@OneToMany
many-to-one --@ManyToOne
many-to-many --@ManyToMany

1. one-to-many
many-to-one
eg : Course management system
Course   1<----->*  Student

Course POJO --- courseId(Integer/Long) , name (unique) , beginDate,endDate , fees, capacity
+ List<Student> students=new AL<>();

Student --- studentId(Integer/Long) , name
+Course chosenCourse

Tables (RDBMS)
courses --parent
students --child --FK column should be added.
owning side --- where actual FK column appears. (eg : many side --students)
inverse side(=non owning side) --- courses.

JPA annotations
Dept 

@OneToMany(mappedBy="dept")
private List<Emp> emps=new AL<>();

Add helper methods in parent(inverse) side --typically for bi dir asso.
addEmp , removeEmp
public void addEmp(Emp e)
{
   emps.add(e);
   e.setDept(this);
}



Emp

@ManyToOne
@JoinColumn(name="dept_id")
private Department dept;


Problems observed
1. FK column name --generated by hibnernate
2. Additional link table was created (in addtion to FK col in students)

Solution
1. How to suply your own FK col name?
@ManyToOne //mandatory
@JoinColumn(name="c_id") //optional BUT reco.
public Course getChosenCourse(){...}




Why hibernate is un-necessarily creating additional link table (in addition to FK column)?
Hibernate doesn't have ANY info regarding which is owning & which is non-owning side of the bi-dir asso. 

How to tell hibernate about owning & inverse side of the assoication ?
In inverse side(Course)
@OneToMany(mappedBy="name of the property as it appears in the owning entity")
eg :@OneToMany(mappedBy="chosenCourse",cascade=CascadeType.ALL)
public List<Student> getStudents() {...}


eg : Create new Dept
Dept d1=new Dept(....);
d1.addEmp(e1),e2,e3,e4.
DAO 
hs.save(d1);


when to catch HibExc / RuntimeExc
getSingleResult -- NoResultExc ---catch RuntimeExc
o.w --catch HibExc



Java SE + Hibernate 

1. Save image to DB
i/p user id & file name to read
(from commons-io.jar)
Use convenient methods of 
org.apache.commons.io.FileUtils
1.1 
static byte[] readFileToByteArray(File file)
Reads the contents of a file into a byte array.

1.2 
static void writeByteArrayToFile(File file, byte[] data)
Writes a byte array to a file creating the file if it does not exist.

2. Retrieve image from DB
i/p customer email & file name to store

-------------------
IMPORTANT
Default fetching policy of JPA/Hibernate
one-to-one --eager
one-to-many --lazy
many-to-one --eager
many-to-many --lazy

When will hibernate throw org.hibernate.LazyInitializationException?

Any time you are accessing , un -fetched data from DB (represented by proxy or collection of proxies) , outside the session scope(in detached manner).
2 triggers
1.Any-To-Many --hibernate rets collection of proxies
2.Session's load method ---hibernate rets single proxy.

Solutions
1. Change def fetch type  of one-to-many , from lazy to eager(in POJO layer)
eg : 
@OneToMany(mappedBy = "selectedCourse",cascade=CascadeType.ALL,
fetch=FetchType.EAGER) 
public List<Student> getStudents() {..}
Dis Adv -- less performant (always results into fetching additional details)
Use case ----size of many is small







2. In DAO layer
-- access the size of the collection in persistent state.
Dis advantage -- multiple select queries are fired by hibernate(select n+1 problem)

3. Better solution
In DAO layer , use join fetch syntax.
eg : 	
String jpql = "select c from Course c join fetch c.students  where c.name=:nm";

Hibernate will fire single inner join query to fetch course + student details (not resulting in LazyInitializationException)
	

---------------
one-one bi dir association between entities (Student <---> Address)

Student --inverse
@OneToOne(mappedBy="stud")
private Address adr;



Address --owning
@OneToOne
@JoinColumn(name="s_id")
private Student stud;


Solve -- Get student details by name

Objective -- Association between entity & value types
Value types -- POJO
1. It won't have annotations
--@Entity & @Id
2. No separate life cycle
It's associated with owning entity life cycle
3. Can't support bi-dir association
4. Typically no separate table , instead details are merged in the owning entity table.

Annotations
1. Class level -- @Embeddable
mandatory

eg : Student HAS-A AdharCard
2. How to tell hibernate to embed details within an entity?
eg :
Student class
@Embedded //optional BUT reco
private AdharCard card


one to many association between entity n value types
eg : Student HAS-A Education qualifications
1. cls level annotation -- @Embeddable
2. How to specify to hibernate , a collection of embeddables
Mandatory annotation
eg : 
@ElementCollection
//to tell hibernate name of collection table & specify FK col name
@CollectionTable //optional(name="stud_quals",joinColumns=@JoinColumn(name="stud_id"))
private List<EduQuals> qualifications=new AL<>();
























Student --- id,name,email,course +
private Address adr;

students --table --inverse side
address --FK --owning side

@OneToOne
public Address getAdr(){....}


Address -- Entity --id , city,state,country
+ private Student stud;

@OneToOne
public  Student getStud(){...}

----------------------
one-to-one (uni directional mapping using shared primary key)
child side (owning side --containing FK)
@Entity(name = "PostDetails")
@Table(name = "post_details")
public class PostDetails {

    @Id
    private Long id;
 
    @Column(name = "created_on")
    private Date createdOn;
 
    @Column(name = "created_by")
    private String createdBy;
 
    @OneToOne(fetch = FetchType.LAZY)
    @MapsId
    private Post post;
...}
